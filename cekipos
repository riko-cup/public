import time
import requests
import threading
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from contextlib import contextmanager

# ==============================
# KONFIGURASI TELEGRAM & GLOBAL VAR
# ==============================
# Ganti dengan token dan chat ID Anda
BOT_TOKEN = "8298779240:AAHdgKmEnI57pCcpfxIwfDHTIKFWS0V1yoQ" 
CHAT_ID = "-4964915114"
BASE_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"

latest_domains = []
latest_update_id = 0
domain_lock = threading.Lock()
# Event ini akan mengatur kapan periodic_check_thread harus bangun
new_list_event = threading.Event() 

def send_telegram_message(message):
    try:
        url = f"{BASE_URL}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": message}
        requests.post(url, data=payload)
    except Exception as e:
        print(f"❌ Gagal kirim ke Telegram: {e}")

# ==============================
# MANAJER KONTEKS UNTUK WEBDRIVER
# ==============================
@contextmanager
def get_webdriver():
    options = Options()
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-gpu")
    options.add_argument("--headless")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1920,1080")
    driver = None
    try:
        # Asumsikan chromedriver ada di PATH
        driver = webdriver.Chrome(service=Service(), options=options) 
        yield driver
    finally:
        if driver:
            driver.quit()

# ==============================
# CEK SATU DOMAIN (PAKAI ELEMEN DARI BATCH)
# ==============================
def check_single_domain(driver, domain):
    try:
        driver.get("https://trustpositif.komdigi.go.id/")

        # Klik pop-up modal
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "press-to-modal"))
        ).click()
        time.sleep(1)

        # Isi domain
        input_area = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "input-data"))
        )
        input_area.clear()
        input_area.send_keys(domain)

        # Klik tombol cek
        driver.find_element(By.ID, "text-footer1").click()
        time.sleep(5)

        # Ambil hasil
        row = driver.find_element(By.CSS_SELECTOR, "#daftar-block tbody tr")
        cells = row.find_elements(By.TAG_NAME, "td")

        if len(cells) >= 2:
            domain_text = cells[0].text.strip()
            status_text = cells[1].text.strip().lower()
            status_text = status_text.replace("\n", " ").replace("\xa0", " ").strip()

            if status_text == "ada":
                return f"{domain_text} 🚫 Blocked"
            elif status_text == "tidak ada":
                return f"{domain_text} ✅ Not Blocked"
            else:
                return f"{domain_text} ❓ Tidak diketahui ({status_text})"
        else:
            return f"{domain} ❌ Error: format tabel tidak sesuai"

    except Exception as e:
        return f"{domain} ❌ Error saat cek: {e}"

# ==============================
# FUNGSI CEK BANYAK DOMAIN (BATCH 5)
# ==============================
def cek_via_web_scrape(domains_list):
    results = []
    # Gunakan satu driver untuk seluruh batch
    with get_webdriver() as driver: 
        for i in range(0, len(domains_list), 5):
            batch = domains_list[i:i+5]
            try:
                driver.get("https://trustpositif.komdigi.go.id/")
                WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.ID, "press-to-modal"))
                ).click()
                time.sleep(1)

                input_area = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "input-data"))
                )
                input_area.clear()
                input_area.send_keys("\n".join(batch))

                driver.find_element(By.ID, "text-footer1").click()
                time.sleep(5)

                rows = driver.find_elements(By.CSS_SELECTOR, "#daftar-block tbody tr")
                for row in rows:
                    cells = row.find_elements(By.TAG_NAME, "td")
                    if len(cells) >= 2:
                        domain_text = cells[0].text.strip()
                        status_text = cells[1].text.strip().lower()
                        status_text = status_text.replace("\n", " ").replace("\xa0", " ").strip()

                        if status_text == "ada":
                            results.append(f"{domain_text} 🚫 Blocked")
                        elif status_text == "tidak ada":
                            results.append(f"{domain_text} ✅ Not Blocked")
                        else:
                            results.append(f"{domain_text} ❓ Tidak diketahui ({status_text})")
            except Exception as e:
                for d in batch:
                    results.append(f"{d} ❌ Error batch: {e}")
    return results

# ==============================
# THREAD 1: CEK PERINTAH TELEGRAM (Long Polling)
# ==============================
def check_telegram_commands_thread():
    global latest_update_id
    global latest_domains

    while True:
        try:
            # Menggunakan Long Polling (timeout=30) untuk respons yang lebih cepat dan stabil
            url = f"{BASE_URL}/getUpdates?offset={latest_update_id + 1}&timeout=30" 
            res = requests.get(url).json()

            if "result" in res:
                updates = res["result"]
                latest_list_command = None

                for update in updates:
                    current_update_id = update["update_id"]
                    
                    if "message" in update and "text" in update["message"]:
                        text = update["message"]["text"].strip()

                        if text.lower().startswith("/list domain"):
                            # Simpan command, akan diproses di akhir batch update
                            latest_list_command = text 
                            send_telegram_message("✅ Bot menemukan daftar baru. Akan dicek setelah delay selesai...")
                            # Hanya set event, pengecekan list akan dilakukan oleh periodic_check_thread
                            new_list_event.set() 
                            
                        elif text.lower().startswith("/cek "):
                            parts = text.split()
                            if len(parts) >= 2:
                                domain = parts[1]
                                send_telegram_message(f"⏳ Memulai pengecekan manual untuk: {domain}...")
                                threading.Thread(
                                    target=manual_check_thread, args=(domain,), daemon=True
                                ).start()
                        
                        # Update ID setelah memproses update
                        if current_update_id >= latest_update_id:
                            latest_update_id = current_update_id


                # Proses command /list domain (jika ada)
                if latest_list_command:
                    lines = latest_list_command.splitlines()
                    # Ambil domain dari baris kedua sampai akhir
                    domains_to_check = [line.strip() for line in lines[1:] if line.strip()] 
                    with domain_lock:
                        latest_domains = domains_to_check
                        
        except requests.exceptions.Timeout:
            # Normal jika long polling timeout
            print("⏳ Tidak ada update baru.")
            continue
            
        except Exception as e:
            print(f"❌ Gagal ambil perintah Telegram: {e}")

        # Jeda singkat untuk menghindari flooding API jika ada banyak update cepat
        time.sleep(1) 

# ==============================
# THREAD 2: PENGECEKAN RUTIN (REVISI)
# ==============================
def periodic_check_thread():
    global latest_domains
    
    # Pesan awal dan Tunggu pemicu pertama
    send_telegram_message("⏳ Pengecekan rutin menunggu daftar domain baru (/list domain)...")
    
    while True:
        # Blokir thread hingga new_list_event di-set (ketika /list domain dikirim)
        new_list_event.wait()
        new_list_event.clear() # Reset event agar bisa menunggu lagi

        # Ambil daftar domain
        with domain_lock:
            domains_to_check = latest_domains.copy()

        if not domains_to_check:
            # Kasus seharusnya jarang terjadi karena event.set() dipicu bersama /list domain
            send_telegram_message("🚫 Daftar domain saat ini kosong. Kirim /list domain lagi untuk memulai.")
            continue # Kembali ke awal loop untuk menunggu event lagi

        # --- Bagian Pengecekan ---
        send_telegram_message(f"▶️ Memulai pengecekan {len(domains_to_check)} domain...")
        results = cek_via_web_scrape(domains_to_check)

        if results:
            total = len(results)
            aman = len([r for r in results if "✅ Not Blocked" in r])
            blocked = len([r for r in results if "🚫 Blocked" in r])
            error = len([r for r in results if "❌" in r])

            summary = (
                f"✈️ TOTAL {total} DOMAIN ✈️\n"
                f"✅ AMAN: {aman}\n"
                f"🚫 BLOCKED: {blocked}\n"
                f"🐛 ERROR: {error}"
            )
            send_telegram_message(summary)

            if blocked > 0:
                blocked_domains = [r for r in results if "🚫 Blocked" in r]
                for domain_result in blocked_domains:
                    for _ in range(3):
                        send_telegram_message(f"📌 : {domain_result}")
                        time.sleep(1)
        # --- Akhir Bagian Pengecekan ---

        time.sleep(400)

# ==============================
# THREAD 3: CEK MANUAL (/cek domain)
# ==============================
def manual_check_thread(domain):
    with get_webdriver() as driver:
        hasil = check_single_domain(driver, domain)

        if "🚫 Blocked" in hasil:
            for _ in range(3):
                send_telegram_message(f"📌 : {hasil}")
                time.sleep(1)
        elif "✅ Not Blocked" in hasil:
            send_telegram_message(f"✅ Tidak terblokir: {domain}.")
        else:
            send_telegram_message(f"📌 : {hasil}")

# ==============================
# MULAI SKRIP
# ==============================
if __name__ == "__main__":
    send_telegram_message("🤖 Bot Trustpositif sudah online! Kirim /list domain untuk memulai pengecekan.")

    # Memulai 3 Thread Utama
    threading.Thread(target=check_telegram_commands_thread, daemon=True).start()
    threading.Thread(target=periodic_check_thread, daemon=True).start()

    # Thread Utama (Main Thread) tetap berjalan agar daemon threads tidak mati
    while True:
        time.sleep(1)
