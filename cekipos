import time
import requests
import threading
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from contextlib import contextmanager

# ==============================
# KONFIGURASI TELEGRAM & GLOBAL VAR
# ==============================
# Ganti dengan token dan chat ID Anda (nilai sekarang mengikuti script awal)
BOT_TOKEN = "8298779240:AAHdgKmEnI57pCcpfxIwfDHTIKFWS0V1yoQ" 
CHAT_ID = "-4964915114"
BASE_URL = f"https://api.telegram.org/bot{BOT_TOKEN}"

latest_domains = []
latest_update_id = 0
domain_lock = threading.Lock()

# Event ini digunakan HANYA untuk memulai siklus periodic_check_thread
new_list_event = threading.Event() 

# Lock untuk mencegah 2 thread mengakses WebDriver manual bersamaan (Race Condition)
manual_check_lock = threading.Lock() 

# ==============================
# HELPER: KIRIM PESAN TELEGRAM
# ==============================
def send_telegram_message(message):
    try:
        url = f"{BASE_URL}/sendMessage"
        payload = {"chat_id": CHAT_ID, "text": message}
        requests.post(url, data=payload, timeout=10)
    except Exception as e:
        print(f"❌ Gagal kirim ke Telegram: {e}")

# ==============================
# MANAJER KONTEKS UNTUK WEBDRIVER (PERIODIC)
# ==============================
@contextmanager
def get_webdriver():
    options = Options()
    options.add_argument("--no-sandbox")
    options.add_argument("--disable-gpu")
    options.add_argument("--headless")
    options.add_argument("--disable-dev-shm-usage")
    options.add_argument("--window-size=1920,1080")
    driver = None
    try:
        # Asumsikan chromedriver ada di PATH
        driver = webdriver.Chrome(service=Service(), options=options) 
        yield driver
    finally:
        if driver:
            # Tutup jendela/tab dulu untuk pembersihan
            try:
                driver.close()
            except:
                pass
            try:
                driver.quit()
            except:
                pass

# ==============================
# CEK SATU DOMAIN (DIGUNAKAN OLEH KEDUA MODE)
# ==============================
def check_single_domain(driver, domain):
    try:
        driver.get("https://trustpositif.komdigi.go.id/")

        # Klik pop-up modal
        WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.ID, "press-to-modal"))
        ).click()
        time.sleep(1)

        # Isi domain
        input_area = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "input-data"))
        )
        input_area.clear()
        input_area.send_keys(domain)

        # Klik tombol cek
        driver.find_element(By.ID, "text-footer1").click()
        # tunggu hasil muncul; jika butuh lebih lama, sesuaikan sleep/timeout
        time.sleep(5)

        # Ambil hasil (baris pertama)
        row = driver.find_element(By.CSS_SELECTOR, "#daftar-block tbody tr")
        cells = row.find_elements(By.TAG_NAME, "td")

        if len(cells) >= 2:
            domain_text = cells[0].text.strip()
            status_text = cells[1].text.strip().lower()
            status_text = status_text.replace("\n", " ").replace("\xa0", " ").strip()

            if status_text == "ada":
                return f"{domain_text} 🚫 Blocked"
            elif status_text == "tidak ada":
                return f"{domain_text} ✅ Not Blocked"
            else:
                return f"{domain_text} ❓ Tidak diketahui ({status_text})"
        else:
            return f"{domain} ❌ Error: format tabel tidak sesuai"

    except Exception as e:
        return f"{domain} ❌ Error saat cek: {e}"

# ==============================
# FUNGSI CEK BANYAK DOMAIN (BATCH 5) - PAKAI DRIVER SEMENTARA
# ==============================
def cek_via_web_scrape(domains_list):
    results = []
    # Gunakan driver sekali pakai untuk seluruh batch panggilan ini
    with get_webdriver() as driver: 
        for i in range(0, len(domains_list), 5):
            batch = domains_list[i:i+5]
            try:
                driver.get("https://trustpositif.komdigi.go.id/")
                WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.ID, "press-to-modal"))
                ).click()
                time.sleep(1)

                input_area = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "input-data"))
                )
                input_area.clear()
                input_area.send_keys("\n".join(batch))

                driver.find_element(By.ID, "text-footer1").click()
                time.sleep(5)

                rows = driver.find_elements(By.CSS_SELECTOR, "#daftar-block tbody tr")
                for row in rows:
                    cells = row.find_elements(By.TAG_NAME, "td")
                    if len(cells) >= 2:
                        domain_text = cells[0].text.strip()
                        status_text = cells[1].text.strip().lower()
                        status_text = status_text.replace("\n", " ").replace("\xa0", " ").strip()

                        if status_text == "ada":
                            results.append(f"{domain_text} 🚫 Blocked")
                        elif status_text == "tidak ada":
                            results.append(f"{domain_text} ✅ Not Blocked")
                        else:
                            results.append(f"{domain_text} ❓ Tidak diketahui ({status_text})")
            except Exception as e:
                # Jika batch gagal, tandai semua domain dalam batch sebagai error
                for d in batch:
                    results.append(f"{d} ❌ Error batch: {e}")
    return results

# ==============================
# THREAD 1: CEK PERINTAH TELEGRAM (Long Polling)
# ==============================
def check_telegram_commands_thread():
    global latest_update_id
    global latest_domains

    while True:
        try:
            # Long Polling (timeout=30)
            url = f"{BASE_URL}/getUpdates?offset={latest_update_id + 1}&timeout=30" 
            res = requests.get(url, timeout=40).json()

            if "result" in res:
                updates = res["result"]
                latest_list_command = None

                for update in updates:
                    current_update_id = update["update_id"]
                    
                    if "message" in update and "text" in update["message"]:
                        text = update["message"]["text"].strip()

                        if text.lower().startswith("/list domain"):
                            # Simpan command untuk diproses di akhir batch update
                            latest_list_command = text 
                            send_telegram_message("✅ Bot menemukan daftar baru. Akan dicek di siklus berikutnya.")
                            # Memicu thread rutin HANYA jika ia sedang menunggu
                            new_list_event.set() 
                            
                        elif text.lower().startswith("/cek "):
                            parts = text.split()
                            if len(parts) >= 2:
                                domain = parts[1]
                                send_telegram_message(f"⏳ Memulai pengecekan manual untuk: {domain}...")
                                threading.Thread(
                                    target=manual_check_thread, args=(domain,), daemon=True
                                ).start()
                        
                        # Update ID setelah memproses update
                        if current_update_id >= latest_update_id:
                            latest_update_id = current_update_id


                # Proses command /list domain (jika ada) dan perbarui daftar global
                if latest_list_command:
                    lines = latest_list_command.splitlines()
                    # Ambil baris setelah baris pertama (asumsi user kirim /list domain <newline>domain1...)
                    domains_to_check = [line.strip() for line in lines[1:] if line.strip()] 
                    with domain_lock:
                        latest_domains = domains_to_check
                        
        except requests.exceptions.Timeout:
            print("⏳ Tidak ada update baru.")
            continue
            
        except Exception as e:
            print(f"❌ Gagal ambil perintah Telegram: {e}")

        # Jeda singkat
        time.sleep(1) 

# ==============================
# THREAD 2: PENGECEKAN RUTIN (LOOPING)
# ==============================
def periodic_check_thread():
    global latest_domains
    
    # TAHAP 1: MENUNGGU INPUT PERTAMA
    send_telegram_message("⏳ Pengecekan rutin menunggu daftar domain baru (/list domain)...")
    new_list_event.wait() # Blokir sampai /list domain pertama diterima
    new_list_event.clear() 

    # TAHAP 2: LOOPING PENGECEKAN RUTIN
    while True: 
        
        with domain_lock:
            domains_to_check = latest_domains.copy()
            
        if not domains_to_check:
            # Jika daftar kosong setelah pengecekan pertama, kembali menunggu event
            send_telegram_message("🚫 Daftar domain saat ini kosong. Menghentikan siklus. Kirim /list domain lagi.")
            new_list_event.wait() 
            new_list_event.clear()
            continue 
            
        results = cek_via_web_scrape(domains_to_check)
        
        if results:
            total = len(results)
            aman = len([r for r in results if "✅ Not Blocked" in r])
            blocked = len([r for r in results if "🚫 Blocked" in r])
            error = len([r for r in results if "❌" in r])

            summary = (
                f"✈️ TOTAL {total} DOMAIN ✈️\n"
                f"✅ AMAN: {aman}\n"
                f"🚫 BLOCKED: {blocked}\n"
                f"🐛 ERROR: {error}"
            )
            send_telegram_message(summary)

            if blocked > 0:
                blocked_domains = [r for r in results if "🚫 Blocked" in r]
                for domain_result in blocked_domains:
                    for _ in range(3):
                        send_telegram_message(f"📌 : {domain_result}")
                        time.sleep(1)

        send_telegram_message(f"🔄 Selesai! Pengecekan ulang akan dilakukan dalam 10 detik...") 
        time.sleep(10)
        # Setelah tidur, loop while True akan mengulang dan mengecek daftar yang sama.

# ==============================
# DRIVER POOL UNTUK MANUAL CHECK (REUSE 1 DRIVER)
# ==============================
manual_driver = None

def init_manual_driver():
    """Inisialisasi manual driver (dipanggil sekali, lalu dipakai ulang)."""
    global manual_driver
    if manual_driver is None:
        options = Options()
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-gpu")
        options.add_argument("--headless")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--window-size=1920,1080")
        manual_driver = webdriver.Chrome(service=Service(), options=options)
    return manual_driver

def reset_manual_driver():
    """Reset kalau driver error atau freeze."""
    global manual_driver
    if manual_driver:
        try:
            manual_driver.close()
        except:
            pass
        try:
            manual_driver.quit()
        except:
            pass
    manual_driver = None

# ==============================
# WATCHDOG (RUN WITH TIMEOUT)
# ==============================
def run_with_timeout(func, args=(), timeout=30):
    """Jalankan fungsi dengan timeout (biar gak freeze lama)."""
    result = [None]
    def wrapper():
        try:
            result[0] = func(*args)
        except Exception as e:
            result[0] = f"❌ Error: {e}"
    t = threading.Thread(target=wrapper)
    t.daemon = True
    t.start()
    t.join(timeout)
    if t.is_alive():
        return "❌ Timeout: Selenium hang"
    return result[0]

# ==============================
# THREAD 3: CEK MANUAL (/cek domain) (REVISI BUG FIX)
# ==============================
def manual_check_thread(domain):
    global manual_driver
    with manual_check_lock:  # lock biar gak bentrok akses manual driver
        try:
            driver = init_manual_driver()
            # Run check dengan timeout supaya gak hang selamanya
            hasil = run_with_timeout(check_single_domain, (driver, domain), timeout=25)
        except Exception as e:
            hasil = f"❌ Gagal inisialisasi driver: {e}"
            reset_manual_driver()  # reset kalau gagal

    # Jika timeout atau error, reset driver supaya next call bisa re-init
    if hasil is None or (isinstance(hasil, str) and ("❌ Timeout" in hasil or "❌ Error" in hasil or "Gagal inisialisasi" in hasil)):
        reset_manual_driver()
        send_telegram_message(f"❌ {domain} : Gagal cek (driver direset). Coba lagi sebentar.")
        return

    # Kirim hasil sesuai status
    if "🚫 Blocked" in hasil:
        for _ in range(3):
            send_telegram_message(f"📌 : {hasil}")
            time.sleep(1)
    elif "✅ Not Blocked" in hasil:
        send_telegram_message(f"✅ {domain} : Tidak terblokir")
    else:
        send_telegram_message(f"📌 : {hasil}")

# ==============================
# MULAI SKRIP
# ==============================
if __name__ == "__main__":
    send_telegram_message("🤖 Bot Trustpositif (revisi) sudah online! Kirim /list domain untuk memulai pengecekan.")

    # Memulai 3 Thread Utama
    threading.Thread(target=check_telegram_commands_thread, daemon=True).start()
    threading.Thread(target=periodic_check_thread, daemon=True).start()

    # Thread Utama (Main Thread) tetap berjalan agar daemon threads tidak mati
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Shutdown requested, resetting manual driver...")
        reset_manual_driver()
        print("Bye.")
